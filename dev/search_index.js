var documenterSearchIndex = {"docs":
[{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"EditURL = \"https://github.com/cossio/WhitenedRBMs.jl/blob/master/docs/src/literate/MNIST.jl\"","category":"page"},{"location":"literate/MNIST/#MNIST","page":"MNIST","title":"MNIST","text":"","category":"section"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"We begin by importing the required packages. We load MNIST via the MLDatasets.jl package.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Some references","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"https://www.jmlr.org/beta/papers/v17/14-237.html,","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"http://www.cs.toronto.edu/~tang/papers/RbmZM.pdf,","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"https://doi.org/10.1007/978-3-642-35289-8_3","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"import CairoMakie\nimport Makie\nimport MLDatasets\nimport Flux\nimport RestrictedBoltzmannMachines as RBMs\nimport WhitenedRBMs as WhiteRBMs\nusing Statistics: mean, var\nusing Random: bitrand\nusing RestrictedBoltzmannMachines: BinaryRBM\nusing ValueHistories: MVHistory\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Useful function to plot MNIST digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"\"\"\"\n    imggrid(A)\n\nGiven a four dimensional tensor `A` of size `(width, height, ncols, nrows)`\ncontaining `width x height` images in a grid of `nrows x ncols`, this returns\na matrix of size `(width * ncols, height * nrows)`, that can be plotted in a heatmap\nto display all images.\n\"\"\"\nfunction imggrid(A::AbstractArray{<:Any,4})\n    reshape(permutedims(A, (1,3,2,4)), size(A,1)*size(A,3), size(A,2)*size(A,4))\nend","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now load the MNIST dataset.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Float = Float32\ntrain_x, train_y = MLDatasets.MNIST.traindata()\ntests_x, tests_y = MLDatasets.MNIST.testdata()\ndigit = 8\ntrain_x = Array{Float}(train_x[:, :, train_y .== digit] .> 0.5)\ntests_x = Array{Float}(tests_x[:, :, tests_y .== digit] .> 0.5)\ntrain_y = train_y[train_y .== digit]\ntests_y = tests_y[tests_y .== digit]\ntrain_nsamples = length(train_y)\ntests_nsamples = length(tests_y)\n(train_nsamples, tests_nsamples)","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Initialize and train a whitened RBM","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"rbm = BinaryRBM(Float, (28,28), 200)\nRBMs.initialize!(rbm, train_x)\nrbm_w = WhiteRBMs.whiten_visible_from_data(WhiteRBMs.whiten(rbm), train_x; ϵ=1f-3)\nbatchsize = 256\noptim = Flux.ADAM()\nvm = bitrand(28, 28, batchsize) # fantasy chains\nhistory_w = MVHistory()\npush!(history_w, :lpl, mean(RBMs.log_pseudolikelihood(rbm_w, train_x)))\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Train","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"@time for epoch in 1:100 # track pseudolikelihood every 5 epochs\n    RBMs.pcd!(rbm_w, train_x; epochs=5, vm, history=history_w, batchsize, optim, ϵv=1f-3, whiten_h=false)\n    push!(history_w, :lpl, mean(RBMs.log_pseudolikelihood(rbm_w, train_x)))\nend\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Convert to equivalent RBM (without affine transforms)","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"rbm = WhiteRBMs.blacken(rbm_w)\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"For comparison, we also train a normal (not whitened) RBM.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"rbm_u = BinaryRBM(Float, (28,28), 200)\nRBMs.initialize!(rbm_u, train_x)\nvm = bitrand(28, 28, batchsize)\nhistory_u = MVHistory()\npush!(history_u, :lpl, mean(RBMs.log_pseudolikelihood(rbm_u, train_x)))\n@time for epoch in 1:100 # track pseudolikelihood every 5 epochs\n    RBMs.pcd!(rbm_u, train_x; epochs=5, vm, history=history_u, batchsize, optim)\n    push!(history_u, :lpl, mean(RBMs.log_pseudolikelihood(rbm_u, train_x)))\nend\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot log-pseudolikelihood of train data during learning.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(600, 300))\nax = Makie.Axis(fig[1,1], xlabel=\"epochs\", ylabel=\"pseudolikelihood\")\nMakie.lines!(ax, get(history_u, :lpl)..., label=\"normal\")\nMakie.lines!(ax, get(history_w, :lpl)..., label=\"whitened\")\nMakie.axislegend(ax, position=:rb)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Seconds per epoch.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(600, 300))\nax = Makie.Axis(fig[1,1], xlabel=\"epoch\", ylabel=\"seconds\")\nMakie.lines!(ax, get(history_u, :Δt)..., label=\"normal\")\nMakie.lines!(ax, get(history_w, :Δt)..., label=\"whitened\")\nMakie.axislegend(ax, position=:rt)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Log-pseudolikelihood vs. computation time instead of epoch count.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(600, 300))\nax = Makie.Axis(fig[1,1], xlabel=\"seconds\", ylabel=\"pseudolikelihood\")\nMakie.lines!(ax, cumsum([0; get(history_u, :Δt)[2]])[1:5:end], get(history_u, :lpl)[2], label=\"normal\")\nMakie.lines!(ax, cumsum([0; get(history_w, :Δt)[2]])[1:5:end], get(history_w, :lpl)[2], label=\"whitened\")\nMakie.axislegend(ax, position=:rb)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now we do the Gibbs sampling to generate RBM digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nrows, ncols = 10, 15\n@time fantasy_x_w = RBMs.sample_v_from_v(rbm_w, bitrand(28,28,nrows*ncols); steps=10000)\n@time fantasy_x_u = RBMs.sample_v_from_v(rbm_u, bitrand(28,28,nrows*ncols); steps=10000)\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot the resulting samples.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Normal RBM.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(40ncols, 40nrows))\nax = Makie.Axis(fig[1,1], yreversed=true)\nMakie.image!(ax, imggrid(reshape(fantasy_x_u, 28, 28, ncols, nrows)), colorrange=(1,0))\nMakie.hidedecorations!(ax)\nMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Whitened RBM.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(40ncols, 40nrows))\nax = Makie.Axis(fig[1,1], yreversed=true)\nMakie.image!(ax, imggrid(reshape(fantasy_x_w, 28, 28, ncols, nrows)), colorrange=(1,0))\nMakie.hidedecorations!(ax)\nMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [WhitenedRBMs]","category":"page"},{"location":"reference/#RestrictedBoltzmannMachines.RBM-Tuple{WhitenedRBMs.WhiteRBM}","page":"Reference","title":"RestrictedBoltzmannMachines.RBM","text":"RBM(white_rbm::WhiteRBM)\n\nReturns an (unwhitened) RBM which neglects the affine transforms of white_rbm. The resulting model is not equivalent to the original white_rbm. To construct an equivalent model, use the function blacken(white_rbm) instead (see blacken).\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.WhiteRBM-Tuple{RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"WhitenedRBMs.WhiteRBM","text":"WhiteRBM(rbm)\n\nCreates a WhiteRBM with identity transforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.one-Tuple{WhitenedRBMs.Affine}","page":"Reference","title":"Base.one","text":"one(t::Affine)\n\nReturns the identity affine transformation, which maps all points to themselves.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.zero-Tuple{WhitenedRBMs.Affine}","page":"Reference","title":"Base.zero","text":"zero(t::Affine)\n\nReturns the zero affine transformation, which maps all points to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.BinaryWhiteRBM-Tuple{AbstractArray, AbstractArray, AbstractArray, WhitenedRBMs.Affine, WhitenedRBMs.Affine}","page":"Reference","title":"WhitenedRBMs.BinaryWhiteRBM","text":"BinaryWhiteRBM(a, b, w, affine_v, affine_h)\nBinaryWhiteRBM(a, b, w)\n\nConstruct a whitened RBM with binary visible and hidden units.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.blacken-Tuple{WhitenedRBMs.WhiteRBM}","page":"Reference","title":"WhitenedRBMs.blacken","text":"blacken(white_rbm::WhiteRBM)\n\nConstructs a plain RBM equivalent to the given white_rbm. The energies assigned by the two models differ by a constant amount,\n\nE(vh) - tildeE(vh) = mathbfa^top mathbbA^top tildemathbbW mathbbBmathbfb\n\nwhere tildeE(vh) is the energy assigned by white_rbm and E(vh) is the energy assigned by the RBM constructed by this method.\n\nThis is the inverse operation of whiten, always returning an ordinary RBM.\n\nTo construct an RBM that simply neglects the transformations, call RBM(white_rbm) instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.hidden_affine_from_inputs-Tuple{WhitenedRBMs.WhiteRBM, AbstractArray}","page":"Reference","title":"WhitenedRBMs.hidden_affine_from_inputs","text":"hidden_affine_from_inputs(white_rbm, data; wts = nothing, ϵ = 0)\n\nReturns the affine transformation that standardizes the hidden inputs. Note that only the variances are scaled to unity, but the covariance matrix is not diagonalized.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.safe_whiten-Union{Tuple{Ah}, Tuple{Av}, Tuple{WhitenedRBMs.WhiteRBM{V, H, W, Av, Ah} where {V, H, W}, Av, Ah}} where {Av, Ah}","page":"Reference","title":"WhitenedRBMs.safe_whiten","text":"safe_whiten(white_rbm, affine_v, affine_h)\n\nLike whiten(white_rbm, affine_v, affine_h), but ensures that the returned WhiteRBM is of the same type as white_rbm (in particular, preserving the types of the affine transformations).\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.shift_fields","page":"Reference","title":"WhitenedRBMs.shift_fields","text":"shift_fields(layer, offset)\n\nAdds offset to the layer fields.\n\n\n\n\n\n","category":"function"},{"location":"reference/#WhitenedRBMs.visible_affine_from_data-Tuple{WhitenedRBMs.WhiteRBM, AbstractArray}","page":"Reference","title":"WhitenedRBMs.visible_affine_from_data","text":"visible_affine_from_data(white_rbm, data; wts = nothing, ϵ = 0)\n\nReturns the affine transformation that whitens the visible data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.whiten-Tuple{RestrictedBoltzmannMachines.RBM, WhitenedRBMs.Affine, WhitenedRBMs.Affine}","page":"Reference","title":"WhitenedRBMs.whiten","text":"whiten(rbm::RBM, affine_v, affine_h)\n\nConstructs a WhiteRBM equivalent to the given rbm. The energies assigned by the two models differ by a constant amount,\n\nE(vh) - tildeE(vh) = mathbfa^top mathbbA^top tildemathbbW mathbbBmathbfb\n\nwhere E(vh) is the energy assigned by the original rbm, and tildeE(vh) is the energy assigned by the returned WhiteRBM.\n\nThis is the inverse operation of blacken, always returning a WhiteRBM.\n\nTo construct a WhiteRBM that simply includes these transforms, call WhiteRBM(rbm, affine_v, affine_h) instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#WhitenedRBMs.whitener-Tuple{AbstractVector, AbstractMatrix}","page":"Reference","title":"WhitenedRBMs.whitener","text":"whitener(μ, C)\n\nReturns the Affine transform that whitens data with mean μ and covariance C.\n\n\n\n\n\n","category":"method"},{"location":"#WhitenedRBMs.jl-Documentation","page":"Home","title":"WhitenedRBMs.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package to train and simulate whitened Restricted Boltzmann Machines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package does not export any symbols.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the functions have a helpful docstring. See Reference section.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not registered. Install with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/cossio/WhitenedRBMs.jl\")","category":"page"},{"location":"#Related","page":"Home","title":"Related","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is based on the RestrictedBoltzmannMachines Julia package, which defines the RBM and layer types. We refer to RestrictedBoltzmannMachines by the shorter name RBMs, as if it were imported by the line","category":"page"},{"location":"","page":"Home","title":"Home","text":"import RestrictedBoltzmannMachines as RBMs","category":"page"}]
}
